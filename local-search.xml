<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java面试题</title>
    <link href="/2022/11/25/java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/11/25/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h3><p>对于不清楚的可以这样解释：平常用到的地方不是特別多，有些记不太清楚了！</p><h4 id="JDK-和-JRE-有什么区别？"><a href="#JDK-和-JRE-有什么区别？" class="headerlink" title="JDK 和 JRE 有什么区别？"></a>JDK 和 JRE 有什么区别？</h4><p>  • JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。<br>  • JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。<br>  • 具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><h4 id="x3D-x3D-和-equals-的区别是什么？"><a href="#x3D-x3D-和-equals-的区别是什么？" class="headerlink" title="&#x3D;&#x3D; 和 equals 的区别是什么？"></a>&#x3D;&#x3D; 和 equals 的区别是什么？</h4><p>&#x3D;&#x3D;：比较基本数据类型时，是比较的值；比较引用数据类型时，比较的是引用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;string&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;string&quot;</span>);<br>System.out.println(x==y); <span class="hljs-comment">// true x 与y都是在常量池所以相等</span><br>System.out.println(x==z); <span class="hljs-comment">// false</span><br>System.out.println(x.equals(y)); <span class="hljs-comment">// true</span><br>System.out.println(x.equals(z)); <span class="hljs-comment">// true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>equals ：对于没有重写object中的equals 方法的类型，默认使用object中的equals ，也就是&#x3D;&#x3D;比较； equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><h4 id="两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;通话&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;重地&quot;</span>;<br>System. out. println(String. format(<span class="hljs-string">&quot;str1：%d | str2：%d&quot;</span>,  str1. hashCode(),str2. hashCode()));<br>System. out. println(str1.equals(str2));<br><br>结果：<br>str1：<span class="hljs-number">1179395</span> | str2：<span class="hljs-number">1179395</span><br><span class="hljs-literal">false</span>   <br></code></pre></td></tr></table></figure><p>很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h4 id="String-和-StringBuffer、StringBuilder-的区别"><a href="#String-和-StringBuffer、StringBuilder-的区别" class="headerlink" title="String 和 StringBuffer、StringBuilder 的区别"></a>String 和 StringBuffer、StringBuilder 的区别</h4><p>​        String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h4 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a>抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ph.Interview;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAbstract</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>        System. out. println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>sayHi();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h4><p>数据单位：字节流（8 bit 图片之类的），字符流（16 bit 文字）</p><p>数据流向：输入流、输出流  （一版我们站在程序（内存）的角度去区分）</p><p>流的角色：节点流（做用在文件之上的）、处理流（作用在流之上的）</p><p>*  抽象基类            节点流（或者叫文件流）     缓冲流(处理流的一种)</p><p>*  InputStream         FileInputStream         BufferedInputStream</p><p>*  OutputStream        FileOutputStream        BufferedOutputStream</p><p>*  Reader             FileReader              BufferedReader</p><p>*  Writer              FileWriter              BufferedWriter</p><h4 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h4><p>• Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。<br>• Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</p><h4 id="ArrayList、LinkedList、Vector区别？"><a href="#ArrayList、LinkedList、Vector区别？" class="headerlink" title="ArrayList、LinkedList、Vector区别？"></a>ArrayList、LinkedList、Vector区别？</h4><p>相同点：都是List接口的实现类。</p><p>性能：在不考虑线程安全的情况下可以使用ArrayList和LinkedList会更快一些； </p><p>线程安全：Vector是有同步锁修饰，是线程安全的；ArrayList和LinkedList是线程不安全的；</p><p> LinkedList的不同：ArrayList和Vector查询和修改快、增删慢，LinkedList增删快。  因为 ArrayList和Vector是基于数组实现的，增删慢（因为牵一发而动全身，复杂度为O（n-i）n表示元素个数，i表示移除元素下标，处理末尾元素，其他的都要移动，所以慢），查询和修改快（走索引）；LinkedList是双向链表，增删快（双向链表，被移除元素标识了前后元素的位置，所以快），查询和修改慢（相比较数组链表不走索引）；</p><p>扩容方法：<br>        ArrayList和Vector类似，ArrayList是右移1位也就是1.5倍扩容，Vector有默认扩容参数，指定的话就再原容量的基础上按照扩容参数进行扩容，不指定的话，就会成倍的扩容； </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList的扩容方法：<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br>Vector的扩容方法：<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                     capacityIncrement : oldCapacity);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;    <br>    <br></code></pre></td></tr></table></figure><h4 id="在-Queue-中-poll-和-remove-有什么区别？"><a href="#在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="在 Queue 中 poll()和 remove()有什么区别？"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>相同点：都是默认移除第一个元素，并返回移除的对象。<br>不同点：1.remove()可以移除对列中指定元素并返回boolean， poll()不可以；</p><p>​2.移除的元素不存在的情况 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException（没有此元素异常） 异常。</p><h4 id="Iterator-怎么使用？有什么特点？"><a href="#Iterator-怎么使用？有什么特点？" class="headerlink" title="Iterator 怎么使用？有什么特点？"></a>Iterator 怎么使用？有什么特点？</h4><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;2&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;3&quot;</span>);<br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-keyword">while</span>(it. hasNext())&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> it.next();<br>            list.add(<span class="hljs-string">&quot;3&quot;</span>);<br>            System. out. println(obj);<br>        &#125;<br>输出：<br><span class="hljs-number">1</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<br>at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:<span class="hljs-number">909</span>)<br>at java.util.ArrayList$Itr.next(ArrayList.java:<span class="hljs-number">859</span>)<br>at com.baidu.Test.main(Test.java:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><h4 id="Boolean类型占几个字节？"><a href="#Boolean类型占几个字节？" class="headerlink" title="Boolean类型占几个字节？"></a>Boolean类型占几个字节？</h4><p>JAVA规范中没有定义boolean类型的大小，但其到底占用了几个字节，还是得依赖于虚拟机的具体实现，符合规范的虚拟机就是1字节或者4字节。</p><p>当Boolean类型数据是数组中的元素时，就是1字节。</p><p>当Boolean类型数据是在Java语言表达式中时，就是4字节。</p><p>解释：</p><p>　在《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持”。接着又说——“在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的<strong>boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替</strong>，而<strong>boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位</strong>” 也就是说JVM规范指出，会将Java表达式中的boolean类型数据当做int型数据处理，也就是4字节。但对于boolean数组当做byte数组处理，也就是每个boolean类型元素1个字节，这样我们可以得出boolean类型单独使用时占了4个字节，在数组中是确定的1个字节。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="线程理论基础"><a href="#线程理论基础" class="headerlink" title="线程理论基础"></a>线程理论基础</h3><h4 id="为什么需要多线程？"><a href="#为什么需要多线程？" class="headerlink" title="为什么需要多线程？"></a>为什么需要多线程？</h4><p>CPU、内存、I&#x2F;O 设备的速度是存在差异的，主要是为了平衡这三者的差异，合理利用cpu性能；</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异；&#x2F;&#x2F; 导致 <code>可见性</code>问题</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；&#x2F;&#x2F; 导致 <code>原子性</code>问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。&#x2F;&#x2F; 导致 <code>有序性</code>问题</li></ul><p>多线程会产生线程不安全的问题：多线程对共享变量的操作可能导致最终的结果不一致。</p><h4 id="什么是可见性？原子性？有序性？"><a href="#什么是可见性？原子性？有序性？" class="headerlink" title="什么是可见性？原子性？有序性？"></a>什么是可见性？原子性？有序性？</h4><p>可见性（cpu缓存引起的）：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>可见性问题：比如线程1对变量i修改了之后，线程2没有立即看到线程1修改的值（线程2读到线程1修改后还未写到主内存中的值）。</p><p>原子性（分时复用引起的）：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>原子性问题：由于CPU分时复用（线程切换）的存在，可能会导致最终写到内存中的结果不一致。</p><p>有序性(重排序引起): 即程序执行的顺序按照代码的先后顺序执行。</p><p>有序性问题: JVM在真正执行，代码可能会发生指令重排序（主要是为了提高性能），从而导致内存可见性问题；</p><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h3 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h3><h4 id="Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例。"><a href="#Synchronized可以作用在哪里-分别通过对象锁和类锁进行举例。" class="headerlink" title="Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。"></a>Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。</h4><p>对象锁：包括<strong>方法锁</strong>(默认锁对象为this,当前实例对象)和<strong>同步代码块锁</strong>(自己指定锁对象)</p><p>类锁：synchronize修饰静态的方法(加在静态方法上)或指定锁对象为Class对象(类名.class)</p><h4 id="加锁和释放锁的原理？"><a href="#加锁和释放锁的原理？" class="headerlink" title="加锁和释放锁的原理？"></a>加锁和释放锁的原理？</h4><p>反编译看monitor指令：使用javap命令反编译查看.class文件的信息，可以看到<code>monitorenter</code>和<code>monitorexit</code>。</p><p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：</p><p>​1、monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</p><p>​2、如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</p><p>​3、这把锁已经被别的线程获取了，等待锁释放 </p><p><code>monitorexit指令</code>：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><h4 id="可重入锁的原理？"><a href="#可重入锁的原理？" class="headerlink" title="可重入锁的原理？"></a>可重入锁的原理？</h4><p>可重入：（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p><p>可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（<strong>前提锁对象得是同一个对象或者class</strong>），不会因为之前已经获取过还没释放而阻塞。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedDemo</span>();<br>        demo.method1();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getId() + <span class="hljs-string">&quot;: method1()&quot;</span>);<br>        method2();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getId()+ <span class="hljs-string">&quot;: method2()&quot;</span>);<br>        method3();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getId()+ <span class="hljs-string">&quot;: method3()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合加锁和释放锁的原理去理解： </p><p>执行monitorenter获取锁</p><ul><li>（monitor计数器&#x3D;0，可获取锁）</li><li>执行method1()方法，monitor计数器+1 -&gt; 1 （获取到锁）</li><li>执行method2()方法，monitor计数器+1 -&gt; 2</li><li>执行method3()方法，monitor计数器+1 -&gt; 3</li></ul><p>执行monitorexit命令</p><ul><li>method3()方法执行完，monitor计数器-1 -&gt; 2</li><li>method2()方法执行完，monitor计数器-1 -&gt; 1</li><li>method2()方法执行完，monitor计数器-1 -&gt; 0 （释放了锁）</li><li>（monitor计数器&#x3D;0，锁被释放了）</li></ul><p>这就是Synchronized的重入性，即在<strong>同一锁程</strong>中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2022/09/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/09/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>一些简单实用的git命令涉及提交文件、回退文件。</p><h2 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h2><p> <img src="https://raw.githubusercontent.com/zhujialongg/pic2/master/image-20220927225714363.png" alt="img"></p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>新建一个文件夹并打开，右键打开Git Bash Hare；</p><p>输入初始化</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>拉仓库</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">&quot;github</span>仓库地址<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>查看当前目录下文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>进入到要操作的文件目录 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  <span class="hljs-string">&quot;文件夹&quot;</span><br></code></pre></td></tr></table></figure><p>使用添加命令到暂存区 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span>  <span class="hljs-string">&quot;文件名&quot;</span><br></code></pre></td></tr></table></figure><p>提交暂存区到仓库</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;本次提交说明&quot;</span><br></code></pre></td></tr></table></figure><p>提交本地仓库到远程仓库</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><p>查看暂存区文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">git ls-files<br></code></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">git reflog<br>或者<br>git <span class="hljs-built_in">log</span> -<span class="hljs-built_in">n</span>(<span class="hljs-comment">-n表示行数，比如-3就是近三行提交记录</span>)<br></code></pre></td></tr></table></figure><h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><p>只回退commit，保留暂存区与工作区</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft 要回退到的版本号</span><br></code></pre></td></tr></table></figure><p>回退commit、add 保留工作区</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--mixed 要回退到的版本号</span><br></code></pre></td></tr></table></figure><p>回退commit、add、工作区</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 要回退到的版本号 </span><br></code></pre></td></tr></table></figure><p>回退暂存区到工作区</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git restore <span class="hljs-comment">--staged  要回退的文件名</span><br></code></pre></td></tr></table></figure><h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>查看工作区与暂存区冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs \">git diff<br></code></pre></td></tr></table></figure><p>查看暂存区与本地仓库冲突</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> HEAD 文件名<br>或者<br>git <span class="hljs-built_in">diff</span> 历史版本号 文件名<br></code></pre></td></tr></table></figure><p>建议多敲命令，少用工具！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh连接git操作</title>
    <link href="/2022/09/25/ssh%E8%BF%9E%E6%8E%A5git%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/09/25/ssh%E8%BF%9E%E6%8E%A5git%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h4><p>​有git账号：<a href="https://github.com/">https://github.com</a></p><p>​git已经安装：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><h4 id="1、先看本地有无ssh"><a href="#1、先看本地有无ssh" class="headerlink" title="1、先看本地有无ssh"></a>1、先看本地有无ssh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -al ~/.ssh<br></code></pre></td></tr></table></figure><h4 id="2、生成-x2F-修改密钥"><a href="#2、生成-x2F-修改密钥" class="headerlink" title="2、生成&#x2F;修改密钥"></a>2、生成&#x2F;修改密钥</h4><p>没有的话使用命令创建：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ssh-keygen</span><br></code></pre></td></tr></table></figure><p>重新生成命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ssh</span>-keygen -t rsa -b <span class="hljs-number">4096</span> -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>这里会出现：</p><p>​1、让你指定存密钥的路径，可以直接敲回车，让它按默认路径就好，默认路径就是后面括号里的；</p><p>​2、如果之前在这个默认位置设置过密钥，这里就会问你要不要覆盖之前的密钥，直接输入y修改；</p><p>​3、然后让你设置密码，可以不用设，设的话每次都都要输入，很麻烦，不设就直接敲回车跳过；</p><p>结果如下图就是生成成功了！</p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/image-20220925170814583.png" alt="image-20220925170814583" style="zoom:50%;" /><h4 id="3、添加ssh密钥到ssh-agent"><a href="#3、添加ssh密钥到ssh-agent" class="headerlink" title="3、添加ssh密钥到ssh-agent"></a>3、添加ssh密钥到ssh-agent</h4><p>启动ssh-agent</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">eval <span class="hljs-constructor">$(<span class="hljs-params">ssh</span>-<span class="hljs-params">agent</span> -<span class="hljs-params">s</span>)</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/2.png"></p><p>ssh私钥添加到ssh-agent</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ssh-add ~<span class="hljs-regexp">/.ssh/i</span>d_rsa<br></code></pre></td></tr></table></figure><p> 结果如下：</p><p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/3.png"></p><h4 id="4、复制ssh公钥到GitHub"><a href="#4、复制ssh公钥到GitHub" class="headerlink" title="4、复制ssh公钥到GitHub"></a>4、复制ssh公钥到GitHub</h4><p>打开注册好的github，点击Settings，进入设置</p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/4.jpg" style="zoom:50%;" /><p>点击ssh and gpg keys 再点击 new ssh key</p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/5.jpg" style="zoom:50%;" /><p>title：起个名字</p><p>key：粘贴刚刚复制的公钥</p><p>点add ssh key提交</p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/6.jpg" style="zoom:50%;" /><p>提交后显示</p>  <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/7.jpg" style="zoom:50%;" /><h4 id="5、测试是否配置成功"><a href="#5、测试是否配置成功" class="headerlink" title="5、测试是否配置成功"></a>5、测试是否配置成功</h4><p>回到命令窗口 输入命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>这样就成功了！</p><p> <img src="https://cdn.jsdelivr.net/gh/zhujialongg/pic2/8.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2022/09/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/09/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h4><p><img src="https://img0.baidu.com/it/u=3781646237,3508226731&fm=253&app=138&size=w931&n=0&f=JPEG&fmt=auto?sec=1664125200&t=fd1bc4e58e1c717e002c15cf76a3e2af" alt="img"></p><p>在知识的海洋里，我们都还只是一条淡水鱼！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
